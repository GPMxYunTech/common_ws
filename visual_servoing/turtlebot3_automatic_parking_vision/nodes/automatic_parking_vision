#!/usr/bin/env python
# -*- coding: utf-8 -*-

################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

# Authors: Leon Jung




import rospy
import numpy as np
import tf
from enum import Enum
from nav_msgs.msg import Odometry
from ar_track_alvar_msgs.msg import AlvarMarkers
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import math
import time
from ekf import KalmanFilter
from std_msgs.msg import Bool
import Tkinter as tk
from Tkinter import *
import os
import signal

MARKER_ID_DETECTION = 7

class AutomaticParkingVision():
    def __init__(self):
        self.sub_odom_robot = rospy.Subscriber('/odom', Odometry, self.cbGetRobotOdom, queue_size = 1)
        self.sub_info_marker = rospy.Subscriber('/ar_pose_marker', AlvarMarkers, self.cbGetMarkerOdom, queue_size = 1)
        self.startflag = rospy.Subscriber('/lets_move_finished', Bool, self.cbGetStartflag, queue_size = 1)

        self.pub_cmd_vel = rospy.Publisher('/cmd_vel', Twist, queue_size=1)#/cmd_vel_mux/input/teleop

        self.ParkingSequence = Enum('ParkingSequence', 'searching_parking_lot changing_direction moving_nearby_parking_lot parking_1 parking_2 stop finished again back changing_direction_sec')
        self.NearbySequence = Enum('NearbySequence', 'initial_turn go_straight turn_right parking ')
        
        self.check_wait_time =0
        self.init_pose_and_parame()

        self.frount = False
        self.start_flag = False

        self.parking_step =1
        self.loop_rate = rospy.Rate(10) # 10hz
###視窗程式
        self.window = tk.Tk()
        self.window.geometry('500x500') 
        # self.window.title('information')
        # termf = Frame(self.window, height=100, width=100)
        self.labelParkingSequence = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_ParkingSequence = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black') 

        self.labelNearbySequence = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_NearbySequence = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black') 

        self.labelrobot_2d_pose_x = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_robot_2d_pose_x = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black') 

        self.labelrobot_2d_pose_y= tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_robot_2d_pose_y = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')  

        self.labelrobot_2d_theta= tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_robot_2d_theta = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')   

        self.labelmarker_2d_pose_x= tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_marker_2d_pose_x = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')        

        self.labelmarker_2d_pose_y= tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_marker_2d_pose_y = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')     

        self.labelmarker_2d_theta= tk.Label(self.window, text="", font=('Helvetica', 12), fg='black')
        self.label_marker_2d_theta = tk.Label(self.window, text="", font=('Helvetica', 12), fg='black') 
        
        
        self.update_window()
        
        self.window.mainloop()
###

        # while not rospy.is_shutdown():
        #     if self.is_odom_received is True and self.start_flag is True:
        #         self.fnParking()
            
        #     self.loop_rate.sleep()
        
        # rospy.on_shutdown(self.fnShutDown)

    

    def update_window(self):
        if self.is_odom_received is True and self.start_flag is True:
                self.fnParking()
            
        self.loop_rate.sleep()
        
        if self.current_parking_sequence == self.ParkingSequence.searching_parking_lot.value:
            sequence = "searching_parking_lot"
        elif self.current_parking_sequence == self.ParkingSequence.changing_direction.value:
            sequence = "changing_direction"
        elif self.current_parking_sequence == self.ParkingSequence.moving_nearby_parking_lot.value:
            sequence = "moving_nearby_parking_lot"
        elif self.current_parking_sequence == self.ParkingSequence.parking_1.value:
            sequence = "parking_1"
        elif self.current_parking_sequence == self.ParkingSequence.again.value:
            sequence = "again"
        elif self.current_parking_sequence == self.ParkingSequence.back.value:
            sequence = "back"
        elif self.current_parking_sequence == self.ParkingSequence.changing_direction_sec.value:
            sequence = "changing_direction_sec"
        elif self.current_parking_sequence == self.ParkingSequence.parking_2.value:
            sequence = "parking_2"
        elif self.current_parking_sequence == self.ParkingSequence.stop.value:
            sequence = "stop"
        
        base = 0
        self.labelParkingSequence.configure(text="ParkingSequence ")
        self.labelParkingSequence.place(x=0, y=base)        
        self.label_ParkingSequence.configure(text=sequence)
        self.label_ParkingSequence.place(x=200, y=base)

        base1 = base+40
        self.labelrobot_2d_pose_x.configure(text="robot_2d_pose_x: ")
        self.labelrobot_2d_pose_x.place(x=0, y=base1)        
        self.label_robot_2d_pose_x.configure(text=self.robot_2d_pose_x)
        self.label_robot_2d_pose_x.place(x=200, y=base1)

        self.labelrobot_2d_pose_y.configure(text="robot_2d_pose_y: ")
        self.labelrobot_2d_pose_y.place(x=0, y=base1+30)
        self.label_robot_2d_pose_y.place(x=200, y=base1+30)
        self.label_robot_2d_pose_y.configure(text=self.robot_2d_pose_y)

        self.labelrobot_2d_theta.configure(text="robot_2d_theta: ")
        self.labelrobot_2d_theta.place(x=0, y=base1+60)
        self.label_robot_2d_theta.place(x=200, y=base1+60)
        self.label_robot_2d_theta.configure(text=self.robot_2d_theta)

        base2 = base1+100
        self.labelmarker_2d_pose_x.configure(text="marker_2d_pose_x: ")
        self.labelmarker_2d_pose_x.place(x=0, y=base2)
        self.label_marker_2d_pose_x.place(x=200, y=base2)
        self.label_marker_2d_pose_x.configure(text=self.marker_2d_pose_x)

        self.labelmarker_2d_pose_y.configure(text="marker_2d_pose_y: ")
        self.labelmarker_2d_pose_y.place(x=0, y=base2+30)
        self.label_marker_2d_pose_y.place(x=200, y=base2+30)
        self.label_marker_2d_pose_y.configure(text=self.marker_2d_pose_y)

        self.labelmarker_2d_theta.configure(text="marker_2d_theta ")
        self.labelmarker_2d_theta.place(x=0, y=base2+60)
        self.label_marker_2d_theta.place(x=200, y=base2+60)
        self.label_marker_2d_theta.configure(text=self.marker_2d_theta)
        self.window.after(100, self.update_window)



    def init_pose_and_parame(self):
        self.current_nearby_sequence = self.NearbySequence.initial_turn.value
        self.current_parking_sequence = self.ParkingSequence.searching_parking_lot.value

        self.robot_2d_pose_x = .0
        self.robot_2d_pose_y = .0
        self.robot_2d_theta = .0
        self.marker_2d_pose_x = .0
        self.marker_2d_pose_y = .0
        self.marker_2d_theta = .0

        self.previous_robot_2d_theta = .0
        self.total_robot_2d_theta = .0
        self.is_triggered = False
        self.is_sequence_finished = False
        self.is_odom_received = False
        self.is_marker_pose_received = False

        ekf_theta.init(1,1,5)
        ekf_x.init(1,1,5)
        ekf_y.init(1,1,5)

    def cbGetStartflag(self, startflag_msg):
        self.start_flag = startflag_msg.data #used to bo true


    def cbGetRobotOdom(self, robot_odom_msg):
        if self.is_odom_received == False:
            self.is_odom_received = True 
        
        pos_x, pos_y, theta = self.fnGet2DRobotPose(robot_odom_msg)

        self.robot_2d_pose_x = pos_x
        self.robot_2d_pose_y = pos_y
        self.robot_2d_theta = theta

        if (self.robot_2d_theta - self.previous_robot_2d_theta) > 5.:
            d_theta = (self.robot_2d_theta - self.previous_robot_2d_theta) - 2 * math.pi
        elif (self.robot_2d_theta - self.previous_robot_2d_theta) < -5.:
            d_theta = (self.robot_2d_theta - self.previous_robot_2d_theta) + 2 * math.pi
        else:
            d_theta = (self.robot_2d_theta - self.previous_robot_2d_theta)

        self.total_robot_2d_theta = self.total_robot_2d_theta + d_theta
        self.previous_robot_2d_theta = self.robot_2d_theta

        self.robot_2d_theta = self.total_robot_2d_theta
        #print math.degrees(self.robot_2d_theta)

    def cbGetMarkerOdom(self, markers_odom_msg):
        for marker_odom_msg in markers_odom_msg.markers:
            if marker_odom_msg.id == MARKER_ID_DETECTION:
                if self.is_marker_pose_received == False:
                    self.is_marker_pose_received = True

                pos_x, pos_y, theta = self.fnGet2DMarkerPose(marker_odom_msg)

                self.marker_2d_pose_x = pos_x
                self.marker_2d_pose_y = pos_y
                self.marker_2d_theta = theta - math.pi

                #print math.degrees(self.marker_2d_theta)

    def fnParking(self):
        if self.current_parking_sequence == self.ParkingSequence.searching_parking_lot.value:
            self.is_sequence_finished = self.fnSeqSearchingGoal()
            
            if self.is_sequence_finished == True:
                #print "Finished 1"
                self.current_parking_sequence = self.ParkingSequence.changing_direction.value
                self.is_sequence_finished = False

        elif self.current_parking_sequence == self.ParkingSequence.changing_direction.value:
            #print "changing_direction"
            self.is_sequence_finished = self.fnSeqChangingDirection()
            
            if self.is_sequence_finished == True:
                #print "Finished 2"
                self.current_parking_sequence = self.ParkingSequence.moving_nearby_parking_lot.value
                self.is_sequence_finished = False

        elif self.current_parking_sequence == self.ParkingSequence.moving_nearby_parking_lot.value:
            #print "moving_nearby_parking_lot"
            self.is_sequence_finished = self.fnSeqMovingNearbyParkingLot()
            
            if self.is_sequence_finished == True:
                #print "Finished 3"
                self.current_parking_sequence = self.ParkingSequence.parking_1.value
                self.is_sequence_finished = False

        elif self.current_parking_sequence == self.ParkingSequence.parking_1.value:
            self.parking_step =1
            self.is_sequence_finished = self.fnSeqParking()
            
            if self.is_sequence_finished == True:
                #print "Finished 4"
                self.current_parking_sequence = self.ParkingSequence.again.value
                self.is_sequence_finished = False
        ###
        elif self.current_parking_sequence == self.ParkingSequence.again.value:
            self.is_sequence_finished = self.fnSeqifagain()
            
            if self.is_sequence_finished == True:
                #print "changing_direction_2"
                self.current_parking_sequence = self.ParkingSequence.changing_direction_sec.value
                self.is_sequence_finished = False
            else:
                #print "go back"
                self.current_parking_sequence = self.ParkingSequence.back.value

        elif self.current_parking_sequence == self.ParkingSequence.back.value:
            self.is_sequence_finished = self.fnSeqBack()
            
            if self.is_sequence_finished == True:
                #print "go to step 1"
                self.init_pose_and_parame()
                self.current_parking_sequence = self.ParkingSequence.searching_parking_lot.value
                self.is_sequence_finished = False

        elif self.current_parking_sequence == self.ParkingSequence.changing_direction_sec.value:
            #print "changing_direction_2"
            self.is_sequence_finished = self.fnSeqlimitdegree()
            
            if self.is_sequence_finished == True:
                #print "Finished changing_direction_2"
                self.current_parking_sequence = self.ParkingSequence.parking_2.value
                self.is_sequence_finished = False
        
        elif self.current_parking_sequence == self.ParkingSequence.parking_2.value:
            self.parking_step =2
            self.is_sequence_finished = self.fnSeqParking()
            
            if self.is_sequence_finished == True:
                #print "Finished 4"
                self.current_parking_sequence = self.ParkingSequence.stop.value
                self.is_sequence_finished = False
        ###
        elif self.current_parking_sequence == self.ParkingSequence.stop.value:
            self.fnStop()
            print "STOP!!!!"
            print self.marker_2d_pose_x,"  ",self.marker_2d_pose_y,"  ",math.degrees(self.marker_2d_theta)
            self.current_parking_sequence = self.ParkingSequence.finished.value
            self.start_flag = False
            rospy.on_shutdown(self.fnShutDown)

    def fnSeqSearchingGoal(self):
        print "fnSeqSearchingGoal"

        if self.is_marker_pose_received is False:
            self.desired_angle_turn = -0.6
            self.fnTurn(self.desired_angle_turn)
        else:
            self.fnStop()
            return True

    def fnSeqChangingDirection(self):
        print "fnSeqChangingDirection"
        
        desired_angle_turn = -1. *  math.atan2(self.marker_2d_pose_y - 0, self.marker_2d_pose_x - 0)
        ##print desired_angle_turn
        if  not self.frount:
            if desired_angle_turn <0:
                desired_angle_turn = desired_angle_turn + math.pi
            else:
                desired_angle_turn = desired_angle_turn - math.pi
            

        rospy.loginfo("desired_angle_turn %f self.marker_2d_pose_x %f self.marker_2d_pose_y %f"
         , desired_angle_turn, self.marker_2d_pose_x, self.marker_2d_pose_y)

        self.fnTurn(desired_angle_turn)
        
        if abs(desired_angle_turn) < 0.2:
            self.fnStop()
            if self.check_wait_time > 20:
                return True
            else:
                self.check_wait_time =self.check_wait_time  +1
        else:
            self.check_wait_time =0
            return False

    def fnSeqlimitdegree(self):
        self.loop_rate = rospy.Rate(30)
        print "fnSeqlimitdegree"
        if self.frount:
            desired_angle_turn = np.sign(self.marker_2d_theta)*0.1
        else:
            desired_angle_turn = -np.sign(self.marker_2d_theta)*0.1
        
        #print desired_angle_turn
        self.fnTurn(desired_angle_turn)

        #print math.degrees(self.marker_2d_theta)
        
        
        
        
        if self.frount:
            print 180-abs(math.degrees(self.marker_2d_theta))
            if 180-abs(math.degrees(self.marker_2d_theta)) < 0.2:
                self.fnStop()
                if self.check_wait_time > 20:
                    return True
                else:
                    self.check_wait_time =self.check_wait_time  +1
            else:
                self.check_wait_time =0
                return False
            
        else:
            print abs(math.degrees(self.marker_2d_theta))
            if  abs(math.degrees(self.marker_2d_theta)) < 0.2:
                self.fnStop()
                if self.check_wait_time > 20:
                    return True
                else:
                    self.check_wait_time =self.check_wait_time  +1
            else:
                self.check_wait_time =0
                return False
            


    def fnSeqMovingNearbyParkingLot(self):
        if self.current_nearby_sequence == self.NearbySequence.initial_turn.value:
            if self.is_triggered == False:
                self.is_triggered = True
                self.initial_robot_pose_theta = self.robot_2d_theta
                self.initial_robot_pose_x = self.robot_2d_pose_x
                self.initial_robot_pose_y = self.robot_2d_pose_y

                self.initial_marker_pose_theta = self.marker_2d_theta
                self.initial_marker_pose_x = self.marker_2d_pose_x

            if self.initial_marker_pose_theta < 0.0:
                desired_angle_turn = (math.pi / 2.0) + self.initial_marker_pose_theta - (self.robot_2d_theta - self.initial_robot_pose_theta)
            elif self.initial_marker_pose_theta > 0.0:
                desired_angle_turn = -(math.pi / 2.0) + self.initial_marker_pose_theta - (self.robot_2d_theta - self.initial_robot_pose_theta)

            # rospy.loginfo("desired_angle_turn %f self.initial_marker_pose_theta %f self.robot_2d_theta %f self.initial_robot_pose_theta %f"
            # , desired_angle_turn, self.initial_marker_pose_theta, self.robot_2d_theta, self.initial_robot_pose_theta)

            desired_angle_turn = -1. * desired_angle_turn
            print desired_angle_turn
            self.fnTurn(desired_angle_turn)

            if abs(desired_angle_turn) < 0.2:
                self.fnStop()
                if self.check_wait_time > 20:
                    
                    self.current_nearby_sequence = self.NearbySequence.go_straight.value
                    self.is_triggered = False
                else:
                    self.check_wait_time =self.check_wait_time +1
            else:
                self.check_wait_time =0    
            rospy.loginfo("fnSeqMovingNearbyParkingLot 1")

        elif self.current_nearby_sequence == self.NearbySequence.go_straight.value:

            dist_from_start = self.fnCalcDistPoints(self.initial_robot_pose_x, self.robot_2d_pose_x, self.initial_robot_pose_y, self.robot_2d_pose_y)
            if self.frount:
                desired_dist = self.initial_marker_pose_x * abs(math.cos((math.pi / 2.) - self.initial_marker_pose_theta))
            else:
                desired_dist = -1* self.initial_marker_pose_x * abs(math.cos((math.pi / 2.) - self.initial_marker_pose_theta))
            
            #if self.frount:
            remained_dist = desired_dist - dist_from_start
            #else:
            #    remained_dist = dist_from_start - desired_dist 
            
            #remained_dist = desired_dist - dist_from_start
            rospy.loginfo("remained_dist %f desired_dist %f dist_from_start %f", remained_dist, desired_dist, dist_from_start)
            #self.fnStop()
            self.fnGoStraight()
            if abs(remained_dist) < 0.04:
                self.fnStop()
                if self.check_wait_time > 20:
                    
                    self.current_nearby_sequence = self.NearbySequence.turn_right.value
                else:
                    self.check_wait_time =self.check_wait_time +1
            else:
                self.check_wait_time =0      
            rospy.loginfo("fnSeqMovingNearbyParkingLot 2")

        elif self.current_nearby_sequence == self.NearbySequence.turn_right.value:
            if self.is_triggered == False:
                self.is_triggered = True
                self.initial_robot_pose_theta = self.robot_2d_theta
            if self.frount:
                if self.initial_marker_pose_theta < 0.0:
                    desired_angle_turn = -(math.pi / 2.0) + (self.robot_2d_theta - self.initial_robot_pose_theta)
                elif self.initial_marker_pose_theta > 0.0:
                    desired_angle_turn = (math.pi / 2.0) + (self.robot_2d_theta - self.initial_robot_pose_theta)
            else:
                if self.initial_marker_pose_theta < 0.0:
                    desired_angle_turn = (math.pi / 2.0) + (self.robot_2d_theta - self.initial_robot_pose_theta)
                elif self.initial_marker_pose_theta > 0.0:
                    desired_angle_turn = -(math.pi / 2.0) + (self.robot_2d_theta - self.initial_robot_pose_theta)
            
            # rospy.loginfo("desired_angle_turn %f self.robot_2d_theta %f self.initial_robot_pose_theta %f"
            # , desired_angle_turn, self.robot_2d_theta, self.initial_robot_pose_theta)
            print desired_angle_turn
            self.fnTurn(desired_angle_turn)
            rospy.loginfo("fnSeqMovingNearbyParkingLot 3")
            if abs(desired_angle_turn) < 0.2:
                self.fnStop()
                if self.check_wait_time > 20:
                    
                    self.current_nearby_sequence = self.NearbySequence.parking.value
                    self.is_triggered = False
                    return True                
                else:
                    self.check_wait_time =self.check_wait_time  +1
            else:
                self.check_wait_time =0    
        return False

    def fnSeqifagain(self):
        while self.fnSeqChangingDirection() == False:
            print "wait"
        rospy.loginfo("fnSeqifagain")
        #print self.marker_2d_pose_x,"  ",self.marker_2d_pose_y,"  ",math.degrees(self.marker_2d_theta)
        self.dist = abs(self.marker_2d_pose_x*math.cos((np.pi/2)-abs(self.marker_2d_theta)))
        print self.dist
        if  self.dist < 0.02:
            #print "again"
            
            if self.check_wait_time > 20:
                return True
            else:
                self.check_wait_time =self.check_wait_time  +1
        else:
            self.check_wait_time =0
            return False

    def fnSeqParking(self):
        desired_angle_turn = math.atan2(self.marker_2d_pose_y - 0, self.marker_2d_pose_x - 0)
        
        rospy.loginfo("fnSeqParking")
        print desired_angle_turn
        if  not self.frount:
            if desired_angle_turn <0:
                desired_angle_turn = desired_angle_turn + math.pi
            else:
                desired_angle_turn = desired_angle_turn - math.pi
        
        print desired_angle_turn
        if self.parking_step is 1:
            dist_limt =0.25
        elif self.parking_step is 2:
            dist_limt =0.16
            desired_angle_turn=0
        self.fnTrackMarker(-desired_angle_turn)
        print "x"
        print self.marker_2d_pose_x
        
        print self.parking_step

        if (abs(self.marker_2d_pose_x) < dist_limt)  :
            self.fnStop()
            if self.check_wait_time > 20:
                return True
            else:
                self.check_wait_time =self.check_wait_time  +1
        
        else:
            self.check_wait_time =0
            return False
    def fnSeqBack(self):
        self.fnGoBack()
        if abs(self.marker_2d_pose_x) > 0.5:
            self.fnStop()
            return True
        else:
            return False

    def fnStop(self):
        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        #self.pub_cmd_vel.publish(twist)
        self.cmd_pub(twist)

    def fnTurn(self, theta):
        Kp = 0.8

        angular_z = Kp * theta

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        
        if angular_z< 0.2 and angular_z> -0.2:
            if angular_z > 0:
                angular_z =0.2
            else:
                angular_z =-0.2
        twist.angular.z = -angular_z
        #self.pub_cmd_vel.publish(twist)
        self.cmd_pub(twist)

    def fnGoStraight(self):
        twist = Twist()
        twist.linear.x = 0.08
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        #self.pub_cmd_vel.publish(twist)
        self.cmd_pub(twist)

    def fnGoBack(self):
        twist = Twist()
        twist.linear.x = -0.1
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        #self.pub_cmd_vel.publish(twist)
        self.cmd_pub(twist)

    def fnTrackMarker(self, theta):
        Kp = 1

        angular_z = Kp * theta

        twist = Twist()
        twist.linear.x = 0.08
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0

        #if angular_z< 0.2 and angular_z> -0.2:
        #    if angular_z > 0:
        #        angular_z =0.2
        #    else:
        #        angular_z =-0.2

        twist.angular.z = -angular_z
        #self.pub_cmd_vel.publish(twist)
        self.cmd_pub(twist)

    def cmd_pub(self, twist):
        if not self.frount:
            twist.linear.x = -twist.linear.x
        #    twist.angular.z = -twist.angular.z
        if twist.angular.z > 0.8:
            twist.angular.z =0.8 
        elif twist.angular.z < -0.8:
            twist.angular.z =-0.8 
        self.pub_cmd_vel.publish(twist)
        


    def fnGet2DRobotPose(self, robot_odom_msg):
        quaternion = (robot_odom_msg.pose.pose.orientation.x, robot_odom_msg.pose.pose.orientation.y, robot_odom_msg.pose.pose.orientation.z, robot_odom_msg.pose.pose.orientation.w)
        theta = tf.transformations.euler_from_quaternion(quaternion)[2]

        if theta < 0:
            theta = theta + np.pi * 2
        if theta > np.pi * 2:
            theta = theta - np.pi * 2

        pos_x = robot_odom_msg.pose.pose.position.x
        pos_y = robot_odom_msg.pose.pose.position.y

        return pos_x, pos_y, theta

    def fnGet2DMarkerPose(self, marker_odom_msg):
        quaternion = (marker_odom_msg.pose.pose.orientation.x, marker_odom_msg.pose.pose.orientation.y, marker_odom_msg.pose.pose.orientation.z, marker_odom_msg.pose.pose.orientation.w)
        theta = tf.transformations.euler_from_quaternion(quaternion)[2]

        theta = theta + np.pi / 2.
        #rospy.loginfo("\ntheta : %4f ,%4f", theta,math.degrees(theta))

        if theta < 0:       #normolize
            theta = theta + np.pi * 2
        if theta > np.pi * 2:
            theta = theta - np.pi * 2

        pos_x = marker_odom_msg.pose.pose.position.x
        pos_y = marker_odom_msg.pose.pose.position.y
	    
        theta = ekf_theta.update(theta)
        pos_x = ekf_x.update(pos_x)
        pos_y = ekf_y.update(pos_y)
        print ekf_x.update(pos_x),ekf_y.update(pos_y),ekf_theta.update(theta) ,"\n"
        return pos_x, pos_y, theta

    def fnCalcDistPoints(self, x1, x2, y1, y2):
        return math.sqrt((x1 - x2) ** 2. + (y1 - y2) ** 2.)

    def fnShutDown(self):
        # rospy.loginfo("Shutting down. cmd_vel will be 0")

        twist = Twist()
        twist.linear.x = 0
        twist.linear.y = 0
        twist.linear.z = 0
        twist.angular.x = 0
        twist.angular.y = 0
        twist.angular.z = 0
        ##self.pub_cmd_vel.publish(twist)


    def main(self):
        rospy.spin()


if __name__ == '__main__':
    rospy.init_node('automatic_parking_vision')
    #print "v2"
    ekf_theta = KalmanFilter()
    ekf_x = KalmanFilter()
    ekf_y = KalmanFilter()
    node = AutomaticParkingVision()
    node.main()
